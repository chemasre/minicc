<!DOCTYPE html>
<html>
<body>
<div style="width:100%; padding: 10pt"><button type="button" id="compile" onclick="Compile()">Compile</button></div>
<textarea id="source" style="float:left; margin:10pt" rows="200" cols="100">
</textarea>
<textarea id="memory" style="float:left; margin:10pt" rows="200" cols="20">
</textarea>
<textarea id="program" style="float:left; margin:10pt" rows="200" cols="60">
</textarea>
<script>

var registerCount = 3;
var registerNames = ["A", "B", "C"];

var tokenTextDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var tokenTextCharacters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
							"k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
							"u", "v", "w", "x", "y", "z",
							"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
							"K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
							"U", "V", "W", "X", "Y", "Z"];
							
var tokenTextSeparators = [" ", "\t", "\n"];

var tokenLineSeparator = "\n";


const tokenTextOpenRoundBracket		= "(";
const tokenTextCloseRoundBracket	= ")";
const tokenTextEqual 			= "=";
const tokenTextAddition 			= "+";
const tokenTextMinus				= "-";
const tokenTextAsterisk				= "*";
const tokenTextDivision				= "/";
const tokenTextIf					= "if";
const tokenTextElse					= "else";
const tokenTextWhile				= "while";
const tokenTextFor					= "for";
const tokenTextOpenClaudator		= "{";
const tokenTextCloseClaudator		= "}";
const tokenTextComma				= ",";
const tokenTextOpenSquareBracket	= "[";
const tokenTextCloseSquareBracket	= "]";
const tokenTextEndSentence			= ";";

const tokenTypeLiteral				= 0;
const tokenTypeOpenRoundBracket		= 1;
const tokenTypeCloseRoundBracket	= 2;
const tokenTypeIdentifier			= 3;
const tokenTypeEqual			= 4;
const tokenTypeAddition				= 5;
const tokenTypeMinus				= 6;
const tokenTypeAsterisk				= 7;
const tokenTypeDivision				= 8;
const tokenTypeIf					= 9;
const tokenTypeElse					= 10;
const tokenTypeWhile				= 12;
const tokenTypeFor					= 13;
const tokenTypeOpenClaudator		= 14;
const tokenTypeCloseClaudator		= 15;
const tokenTypeAddressOf			= 16;
const tokenTypeComma				= 17;
const tokenTypeOpenSquareBracket	= 18;
const tokenTypeCloseSquareBracket	= 19;
const tokenTypeSeparator			= 20;
const tokenTypeEndSentence			= 21;


const parserStateWord = 0;
const parserStateLiteral = 1;
const parserStateSeparator = 2;
const parserStateOther = 3;

var sourceElement;
var programElement;

function IsDigit(c)
{
	var result = false;

	var i = 0;
	while(i < tokenTextDigits.length && !result)
	{
		if(tokenTextDigits[i] == c)
		{
			result = true;
		}
		else
		{
			i++;
		}
	}
		
	return result;
}

function IsCharacter(c)
{
	var result = false;

	var i = 0;
	while(i < tokenTextCharacters.length && !result)
	{
		if(tokenTextCharacters[i] == c)
		{
			result = true;
		}
		else
		{
			i++;
		}
	}
		
	return result;
}

function IsSeparator(c)
{
	var result = false;

	var i = 0;
	while(i < tokenTextSeparators.length && !result)
	{
		if(tokenTextSeparators[i] == c)
		{
			result = true;
		}
		else
		{
			i++;
		}
	}
		
	return result;
}

function TokenTypeName(type)
{
	if(type == tokenTypeLiteral)					{ return "Literal(LIT)"; }
	else if(type == tokenTypeOpenRoundBracket)      { return "RoundBracketOpen(RBO)"; }
	else if(type == tokenTypeCloseRoundBracket)     { return "RoundBracketClose(RBC)"; }
	else if(type == tokenTypeIdentifier)            { return "Identifier(ID)"; }
	else if(type == tokenTypeEqual)	                { return "Equal(EQ)"; }
	else if(type == tokenTypeAddition)              { return "Add(ADD)"; }
	else if(type == tokenTypeMinus)	                { return "Substract(SUB)"; }
	else if(type == tokenTypeAsterisk)              { return "Asterisk(AST)"; }
	else if(type == tokenTypeDivision)		        { return "Division(DIV)"; }
	else if(type == tokenTypeIf)	                { return "If(IF)"; }
	else if(type == tokenTypeElse)                  { return "Else(ELS)"; }
	else if(type == tokenTypeWhile)                 { return "While(WHL)"; }
	else if(type == tokenTypeFor)                   { return "For(FOR)"; }
	else if(type == tokenTypeOpenClaudator)         { return "ClaudatorOpen(CO)"; }
	else if(type == tokenTypeCloseClaudator)        { return "ClaudatorClose(CC)"; }
	else if(type == tokenTypeAddressOf)             { return "Address(ADR)"; }
	else if(type == tokenTypeComma)                 { return "Comma(COM)"; }
	else if(type == tokenTypeOpenSquareBracket)     { return "SquareBracketOpen(SBO)"; }
	else if(type == tokenTypeCloseSquareBracket)    { return "SquareBracketClose(SBC)"; }
	else if(type == tokenTypeSeparator)				{ return "Separator(SEP)"; }
	else if(type == tokenTypeEndSentence)			{ return "SentenceEnd(SND)"; }
	else { return "Unknown"; }
}

function Parse(source)
{
	var tokens = Array();
	
	console.log("Tokenizing");
	
	var parserState = parserStateOther;	
	var tokenText;
	
	var i = 0;
	var line = 0;
	
	var error = false;
	var errorText;
		
	while(i < source.length && !error)	
	{
		var c = source[i];
		
		console.log("Caracter: " + c);		

		if(c == tokenLineSeparator) { line ++; }

		if(parserState == parserStateOther)
		{
			if(IsCharacter(c))
			{
				tokenText = "";
				tokenText += c;

				parserState = parserStateWord;

				i ++;
			}			
			else if(IsDigit(c))
			{
				tokenText = "";
				tokenText += c;
					
				parserState = parserStateLiteral;
				
				i ++;
			}
			else if(IsSeparator(c))
			{
				tokenText = "";
				
				parserState = parserStateSeparator;
				
				i++;
			}
			else if(c == tokenTextOpenRoundBracket)		{ tokens.push([tokenTypeOpenRoundBracket,		""]); i++; }
			else if(c == tokenTextCloseRoundBracket)	{ tokens.push([tokenTypeCloseRoundBracket,		""]); i++; }
			else if(c == tokenTextEqual)				{ tokens.push([tokenTypeEqual,					""]); i++; }
			else if(c == tokenTextAddition)				{ tokens.push([tokenTypeAddition,				""]); i++; }
			else if(c == tokenTextMinus)				{ tokens.push([tokenTypeMinus,					""]); i++; }
			else if(c == tokenTextAsterisk)				{ tokens.push([tokenTypeAsterisk,				""]); i++; }
			else if(c == tokenTextDivision)				{ tokens.push([tokenTypeDivision,				""]); i++; }
			else if(c == tokenTextOpenClaudator)		{ tokens.push([tokenTypeOpenClaudator, 			""]); i++; }
			else if(c == tokenTextCloseClaudator)		{ tokens.push([tokenTypeCloseClaudator, 		""]); i++; }
			else if(c == tokenTextComma)				{ tokens.push([tokenTypeComma, 					""]); i++; }
			else if(c == tokenTextOpenSquareBracket)	{ tokens.push([tokenTypeOpenSquareBracket, 		""]); i++; }
			else if(c == tokenTextCloseSquareBracket)	{ tokens.push([tokenTypeCloseSquareBracket,		""]); i++; }
			else if(c == tokenTextEndSentence)			{ tokens.push([tokenTypeEndSentence,			""]); i++; }
			else { error = true; errorText = "Símbolo " + c + " no reconocido"; }
			
		}
		else if(parserState == parserStateSeparator)
		{
			if(!IsSeparator(c))
			{
				tokens.push([tokenTypeSeparator, tokenText]);
				
				parserState = parserStateOther;
			}
			else
			{
				i ++;
			}
		}
		else if(parserState == parserStateWord)		
		{
			if(!IsCharacter(c) && !IsDigit(c))
			{
				var tokenType;
			
				if(tokenText == tokenTextIf)
				{
					tokenType = tokenTypeIf;
					tokenText = "";
				}
				else if(tokenText == tokenTextElse)
				{
					tokenType = tokenTypeElse;
					tokenText = "";
				}
				else if(tokenText == tokenTextWhile)
				{
					tokenType = tokenTypeWhile;
					tokenText = "";
				}
				else if(tokenText == tokenTextFor)
				{
					tokenType = tokenTypeFor;
					tokenText = "";
				}
				else
				{
					tokenType = tokenTypeIdentifier;
				}
			
				tokens.push([tokenType, tokenText]);
				parserState = parserStateOther;
			}
			else
			{
				tokenText += c;
				i ++;
			}
			
		}
		else if(parserState == parserStateLiteral)		
		{
			if(!IsDigit(c))
			{
				tokens.push([tokenTypeLiteral, tokenText]);
				parserState = parserStateOther;
			}
			else
			{
				tokenText += c;
				i ++;
			}
			
		}	
		
	}
	
	if(error)
	{
		console.log("ERROR: Linea " + line + " columna " + i + ": " + errorText);
		
		return null;
	}
	else
	{
		return tokens;
	}
	

}

function PrintTokens(tokens)
{
	var result = "";
	
	for(var i = 0; i < tokens.length; i ++)
	{
		result += i + ": " + TokenTypeName(tokens[i][0]) + (tokens[i][1].length > 0 ? ":" + tokens[i][1]: "") + "\n";
	}
	
	return result;
}


const nodeTypeProgram					= 0;

const nodeTypeVarDeclaration			= 1;
const nodeTypeVarDeclarationType		= 2;
const nodeTypeVarDeclarationName		= 3;

const nodeTypeFuncDeclaration			= 4;
const nodeTypeFuncDeclarationReturnType	= 5;
const nodeTypeFuncDeclarationName		= 6;

const nodeTypeBlock			= 8;

const nodeTypeAssignation				= 9;
const nodeTypeAssignationLeftSide		= 10;
const nodeTypeAssignationRightSide		= 11;

const nodeTypeMinusSign = 12;
const nodeTypeAdd 		= 13;
const nodeTypeSub 		= 14;
const nodeTypeMul 		= 15;
const nodeTypeDiv 		= 16;
const nodeTypeParenthesis = 17;

function IsType(s)
{
	var result = false;
	
	result = result || (s == "void");
	result = result || (s == "int");
	
	return result;
}

function NodeTypeName(type)
{
	if(type == nodeTypeProgram) { return "Program(PRG)"}
	else if(type == nodeTypeVarDeclaration) { return "VarDeclaration(VD)"}
	else if(type == nodeTypeVarDeclarationType) { return "VarDeclarationType(VDT)"}
	else if(type == nodeTypeVarDeclarationName) { return "VarDeclarationName(VDN)"}
	else if(type == nodeTypeFuncDeclaration) { return "FunDeclaration(FD)"}
	else if(type == nodeTypeFuncDeclarationReturnType) { return "FunDeclarationReturnType(FDR)"}
	else if(type == nodeTypeFuncDeclarationName) { return "FunDeclarationName(FDN)"}
	else if(type == nodeTypeBlock) { return "Block(BLK)"}
	else if(type == nodeTypeAssignation) { return "Assignation(AS)"}
	else if(type == nodeTypeAssignationLeftSide) { return "AssignationLeftSide(ASL)"}
	else if(type == nodeTypeAssignationRightSide) { return "AssignationRightSide(ASR)"}
	else if(type == nodeTypeMinusSign) { return "MinusSign(MS)"}
	else if(type == nodeTypeAdd) { return "Add(ADD)"}
	else if(type == nodeTypeSub) { return "Sub(SUB)"}
	else if(type == nodeTypeMul) { return "Mul(MUL)"}
	else if(type == nodeTypeDiv) { return "Div(DIV)"}
	else if(type == nodeTypeParenthesis) { return "Parentheses(PAR)"}
	else { return "Unknown"; }
}

function SkipSeparators(tokens, i)
{
	var nonSeparatorFound  = false;
	
	while(i < tokens.length && !nonSeparatorFound)
	{
		if(tokens[i][0] == tokenTypeSeparator)
		{
			console.log("Skipping separator");
			i ++;
		}
		else
		{
			console.log("Found non separator");
			nonSeparatorFound = true;
		}
	}
	
	return i;
}

function BuildBlock(tokens, i)
{
	var node = { type: nodeTypeBlock, childs: [], content: null }
	
	var error = false;
	var errorText = "";
	
	console.log("Building block");
	
	i = SkipSeparators(tokens, i);
	
	if(i < tokens.length)
	{
		if(tokens[i][0] == tokenTypeOpenClaudator)
		{
			console.log("Block start found");
			
			var blockBuilt = false;
			
			i = i + 1;
			
			
			while(i < tokens.length && !blockBuilt && !error)
			{
				console.log("Processing token " + i + " type " + TokenTypeName(tokens[i][0]));

				if(tokens[i][0] == tokenTypeSeparator)
				{
					console.log("Skipping separator");
					i ++;
				}
				else if(tokens[i][0] == tokenTypeIdentifier && IsType(tokens[i][1]) && i < tokens.length - 3)
				{
					// It should be a local variable declaration
					
					console.log("Identifier found");
					
					if(	tokens[i + 1][0] == tokenTypeSeparator &&
						tokens[i + 2][0] == tokenTypeIdentifier && !IsType(tokens[i + 2][1]))
					{
						if(tokens[i + 3][0] == tokenTypeEndSentence)
						{
							// Local declaration found
							
							console.log("Local variable declaration found");
			
							var declarationNode = {type: nodeTypeVarDeclaration, childs:[], content: null};
							declarationNode.childs.push({type: nodeTypeVarDeclarationType, childs: null, content:tokens[i][1]});
							declarationNode.childs.push({type: nodeTypeVarDeclarationName, childs: null, content:tokens[i + 2][1]});
												
							node.childs.push(declarationNode);
							
							i = i + 4;
						}
						else
						{
							error = true;
							errorText = "Error: Se esperaba un símbolo de fin de sentencia cerca de " + tokens[i][1];
						}
					}
					else
					{
						error = true;
						errorText = "Error: Se esperaba una declaración de variable cerca de " + tokens[i][1];
					}
				}
				else if(tokens[i][0] == tokenTypeCloseClaudator)
				{
					blockBuilt = true;
					
					i ++;
				}
				else
				{
					error = true;
					errorText = "Error: Unexpected token " + i;  
				}

				
			}
			
		}
	}
	else
	{
		error = true;
		errorText = "Error: End of file found when looking for block open symbol";  
	}
	
	
	if(error)
	{
		console.log(errorText);
		
		return [null, i];
	}
	else
	{
		return [node, i];
	}
}


function BuildTree(tokens)
{
	var node = { type: nodeTypeProgram, childs: [], content: null };
	
	var i = 0;
	var error = false;
	var errorText = "";
	
	
	while(i < tokens.length && !error)
	{
		console.log("Processing token " + i + " type " + TokenTypeName(tokens[i][0]));

		if(tokens[i][0] == tokenTypeSeparator)
		{
			console.log("Skipping separator");
			i ++;
		}
		else if(tokens[i][0] == tokenTypeIdentifier && IsType(tokens[i][1]) && i < tokens.length - 3)
		{
			// It can be a declaration or a function
			
			console.log("Identifier found");
			
			if(	tokens[i + 1][0] == tokenTypeSeparator &&
				tokens[i + 2][0] == tokenTypeIdentifier && !IsType(tokens[i + 2][1]))
			{
				if(tokens[i + 3][0] == tokenTypeEndSentence)
				{
					// Is a variable declaration
					
					console.log("Variable declaration found");
	
					var declarationNode = {type: nodeTypeVarDeclaration, childs:[], content: null};
					declarationNode.childs.push({type: nodeTypeVarDeclarationType, childs: null, content:tokens[i][1]});
					declarationNode.childs.push({type: nodeTypeVarDeclarationName, childs: null, content:tokens[i + 2][1]});
										
					node.childs.push(declarationNode);
					
					i = i + 4;
				}
				else if(tokens[i + 3][0] == tokenTypeOpenRoundBracket && i < tokens.length - 4)
				{
					// It can be a function declaration
					
					console.log("Function declaration found");

					if(tokens[i + 4][0] == tokenTypeCloseRoundBracket)
					{					
						var functionDeclarationNode = {type: nodeTypeFuncDeclaration, childs:[], content: null};
						functionDeclarationNode.childs.push({type: nodeTypeFuncDeclarationReturnType, childs: null, content:tokens[i][1]});
						functionDeclarationNode.childs.push({type: nodeTypeFuncDeclarationName, childs: null, content:tokens[i + 2][1]});
						
						i = i + 5;

						var blockNode = BuildBlock(tokens, i);
						
						if(blockNode[0] != null)
						{
							functionDeclarationNode.childs.push(blockNode[0]);
							node.childs.push(functionDeclarationNode);
						}
						
						i = blockNode[1];
						
						console.log("Bloque procesado, siguiente indice " + i);
						
					}
					else
					{
						error = true;
						errorText = "Error: Se esperaba un paréntesis de cierre cerca de " + tokens[i][1];
					}
				}
				else
				{
					error = true;
					errorText = "Error: Se esperaba una declaración de función cerca de " + tokens[i][1];
				}
			}
			else
			{
				error = true;
				errorText = "Error: Se esperaba una declaración de variable o función cerca de " + tokens[i][1];
			}
		}
		else
		{
			error = true;
			errorText = "Error: Secuencia no reconocida cerca de " + tokens[i][1] + " token type " + TokenTypeName(tokens[i][0]);
		}
	}
	
	if(error)
	{
		console.log(errorText);
		
		return null;
	}
	else
	{
		return node;
	}
}

function PrintNode(node, text, level)
{
	var result = text;

	var indent = "";
	for(var j = 0; j < level; j ++) { indent = indent + "    "; }
	
	result = result + indent + NodeTypeName(node.type);

	if(node.childs == null)
	{
		result = result + ": " + node.content + "\n";
	}
	else
	{
		result = result + "\n";
		
		for(var i = 0; i < node.childs.length; i ++)
		{
			var n = node.childs[i];
						
			result = PrintNode(n, result, level + 1);
		}

	}
	
	return result;

}

function PrintTree(node)
{
	var result = "";
	
	result = PrintNode(node, result, 0);
	
	return result;

}

function Compile()
{
	var source = sourceElement.value;
	
	var tokens = Parse(source);
	
	if(tokens == null) { return; }
		
	var tokensText = PrintTokens(tokens);
	
	var tree = BuildTree(tokens);
	
	if(tree == null) { return; }
	
	var treeText = PrintTree(tree);
	
	programElement.value = "-----------Tokens-----------\n" + tokensText +
                           "-----------TreeNodes-----------\n" + treeText;

	
}

sourceElement = document.getElementById("source");
programElement = document.getElementById("program");


</script>
</body>
</html>
